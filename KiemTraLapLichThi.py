# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QTableWidgetItem,QMainWindow, QMessageBox,QWidget
import pandas as pd
from ui_main import Ui_MainWindow

class Tab2():
    def __init__(self, parent):
        self.parent = parent

    def load_file_PhanLich_tab2(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self.parent, "Select File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
        if file_name:
            self.parent.label.setText(file_name)
            self.parent.df_input_tab2 = pd.read_excel(file_name)

    def load_file_CBDL(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self.parent, "Select File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
        if file_name:
            self.parent.label_2.setText(file_name)
            self.parent.df_cbdl_tab2 = pd.read_excel(file_name)

    def load_file_date(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self.parent, "Select File", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
        if file_name:
            self.parent.label_3.setText(file_name)
            self.parent.df_date_tab2 = pd.read_excel(file_name)

    def add_violation(self, violations, violation_type, result_code, message, subject_id="", subject_name="", student_id="", exam_date="", exam_time="", extra_info=""):
        violation = {
            "Loại kiểm tra": violation_type,
            "Mã kết quả": result_code,
            "Thông điệp": message,
            "Mã học phần mở rộng": subject_id,
            "Tên học phần": subject_name,
            "Mã sinh viên mở rộng": student_id,
            "Ngày thi": exam_date,
            "Giờ thi": exam_time,
            "Ghi chú": extra_info,
        }
        violations.append(violation)

    def check_student_per_shift(self, df_input):
        count_student = df_input.groupby(['MSV mở rộng', 'Ngày thi', 'Giờ thi']).size().reset_index(name='count')
        violating_students = count_student[count_student['count'] > 1]
        violations = []

        if violating_students.empty:
            self.add_violation(violations, "check_student_per_shift", 0, "Tất cả sinh viên chỉ thi một môn trong một ca thi")
        else:
            for index, row in violating_students.iterrows():
                # Lấy danh sách các môn học mà sinh viên đã thi trong cùng một ca thi
                subjects_thi = df_input[(df_input['MSV mở rộng'] == row['MSV mở rộng']) & 
                                        (df_input['Ngày thi'] == row['Ngày thi']) & 
                                        (df_input['Giờ thi'] == row['Giờ thi'])]['Mã học phần mở rộng'].unique()
                extra_info = f"Mã học phần mở rộng: {', '.join(subjects_thi)}"
                self.add_violation(violations, "check_student_per_shift", 3, 'Sinh viên thi 2 môn trong 1 ca', 
                                student_id=row['MSV mở rộng'], exam_date=row['Ngày thi'], exam_time=row['Giờ thi'],
                                extra_info=extra_info)

        return pd.DataFrame(violations)

    def check_subject_student_list(self, df, df_cbdl):
        master_subjects = set(df_cbdl['Mã học phần mở rộng'].unique())
        missing_info = []

        for subject in master_subjects:
            current_students = set(df[df['Mã học phần mở rộng'] == subject]['MSV mở rộng'].unique())
            master_students = set(df_cbdl[df_cbdl['Mã học phần mở rộng'] == subject]['MSV mở rộng'].unique())
            missing_students = master_students - current_students
            if missing_students:
                missing_students = [str(student) for student in missing_students]
                self.add_violation(missing_info, "check_subject_student_list", 3, "MSV bị thiếu", subject_id=subject, student_id=", ".join(missing_students))

        missing_subjects = master_subjects - set(df['Mã học phần mở rộng'].unique())
        if missing_subjects:

            self.add_violation(missing_info, "check_subject_student_list", 3, "Mã học phần bị thiếu", subject_id=", ".join(missing_subjects))

        if missing_info:
            return pd.DataFrame(missing_info)
        else:
            self.add_violation(missing_info, "check_subject_student_list", 0, "Tất cả các học phần và sinh viên đã đủ")
            return pd.DataFrame(missing_info)

    def check_student_in_room(self, df):
        violations = []

        for subject in df['Mã học phần mở rộng'].unique():
            subject_data = df[df['Mã học phần mở rộng'] == subject]
            students_of_subject = len(subject_data)

            if students_of_subject <= self.STUDENTS_PER_ROOM + 10:
                rooms_for_students = subject_data.groupby(['Giờ thi', 'Ngày thi'])['Mã phòng'].unique()
                for rooms in rooms_for_students:
                    if len(rooms) > 1:
                        self.add_violation(violations, "check_student_in_room", 3, f"Số lượng sinh viên trong 1 phòng chưa được tối ưu", subject_id=subject, extra_info=f"Có thể gộp phòng")
            else:
                for shift in subject_data['Giờ thi'].unique():
                    shift_data = subject_data[subject_data['Giờ thi'] == shift]
                    for room in shift_data['Mã phòng'].unique():
                        students_of_room = shift_data[shift_data['Mã phòng'] == room]
                        if len(students_of_room) > self.STUDENTS_PER_ROOM:
                            self.add_violation(violations, "check_student_in_room", 3, "Mã học phần mở rộng có số lượng sinh viên vượt quá quy mô của phòng", subject_id=subject, exam_time=shift, extra_info=f"Phòng {room} có quá nhiều sinh viên ({len(students_of_room)}) trong ca {shift} cho mã học phần {subject}.")

        if violations:
            return pd.DataFrame(violations)
        else:
            self.add_violation(violations, "check_student_in_room", 0, "Tất cả các phòng đều không có vượt quá quy mô ")
            return pd.DataFrame(violations)

    def check_alter_subjects(self, df):
        alt_subject_dict = df.groupby('Mã học phần mở rộng')['Mã học phần'].apply(list).to_dict()
        notified_subjects = set()
        violations = []

        for main_subject, alt_subjects in alt_subject_dict.items():
            alt_sessions = df[df['Mã học phần mở rộng'].isin([main_subject] + alt_subjects)][['Mã học phần mở rộng', 'Giờ thi', 'Ngày thi']]
            large_subjects = alt_sessions['Mã học phần mở rộng'].value_counts()[lambda x: x > self.MAX_STUDENTS_PER_SHIFT].index

            for subject in large_subjects:
                if subject in notified_subjects:
                    continue

                subject_df = alt_sessions[alt_sessions['Mã học phần mở rộng'] == subject]
                if len(subject_df) <= self.MAX_STUDENTS_PER_SHIFT:
                    if subject_df.groupby(['Giờ thi', 'Ngày thi']).size().gt(1).any():
                        for index, row in subject_df.iterrows():
                            self.add_violation(violations, "check_alter_subjects", 2, "Các học phần thay thế không thi cùng ca", subject_id=subject, exam_date=row['Ngày thi'], exam_time=row['Giờ thi'])
                        notified_subjects.update(alt_subjects)
                else:
                    for exam_date, daily_sessions in subject_df.groupby('Ngày thi'):
                        sessions = daily_sessions['Giờ thi'].unique()
                        sorted_sessions = sorted(sessions, key=lambda x: self.SHIFT.index(x))
                        for i in range(len(sessions)-1):
                            if not ((sorted_sessions[i] == '7h' and sorted_sessions[i+1] == '9h') or (sorted_sessions[i] == '13h30' and sorted_sessions[i+1] == '15h30')):
                                self.add_violation(violations, "check_alter_subjects", 2, "Số lượng sinh viên vượt quá quy mô của 1 ca và không được chia vào các ca liên tiếp", subject_id=main_subject, exam_date=exam_date, exam_time=sessions[i])
                    notified_subjects.add(main_subject)

        if violations:
            return pd.DataFrame(violations)
        else:
            self.add_violation(violations, "check_alter_subjects", 0, "Tất cả học phần thay thế nhau thi cùng 1 ca")
            return pd.DataFrame(violations)


    def check_count_room_shift(self, df):
        reused_message_printed = False
        dates = df['Ngày thi'].unique()
        violations = []

        for date in dates:
            daily_sessions = df[df['Ngày thi'] == date]
            shifts = daily_sessions['Giờ thi'].unique()

            # Chỉ xét chênh lệch phòng khi có ít nhất hai ca thi trong cùng một ngày
            if len(shifts) > 1:
                current_shift_rooms = daily_sessions[daily_sessions['Giờ thi'] == shifts[0]]['Mã phòng'].unique()
                next_shift_rooms = daily_sessions[daily_sessions['Giờ thi'] == shifts[1]]['Mã phòng'].unique()

                shift_rooms_count = abs(len(current_shift_rooms) - len(next_shift_rooms))
                if shift_rooms_count > 3:
                    self.add_violation(violations, "check_count_room_shift", 1, "Có sự chênh lệch phòng giữa các ca thi", exam_date=date, extra_info=f"Chênh lệch số lượng phòng: {shift_rooms_count} giữa ca thi {shifts[0]} và {shifts[1]}.")
                    reused_message_printed = True

        if not violations:
            self.add_violation(violations, "check_count_room_shift", 0, "Số lượng phòng của 2 ca không có sự chênh lệch")

        return pd.DataFrame(violations)

    def check_room_reuse(self, df):
        reused_message_printed = False
        dates = df['Ngày thi'].unique()
        violations = []

        for date in dates:
            daily_sessions = df[df['Ngày thi'] == date]
            for shifts in [(self.SHIFT[0], self.SHIFT[1]), (self.SHIFT[2], self.SHIFT[3])]:
                current_shift_rooms = daily_sessions[daily_sessions['Giờ thi'] == shifts[0]]['Mã phòng']
                next_shift_rooms = daily_sessions[daily_sessions['Giờ thi'] == shifts[1]]['Mã phòng']

                reused_rooms = set(current_shift_rooms).intersection(next_shift_rooms)
                non_reused_rooms = set(next_shift_rooms) - reused_rooms
                if non_reused_rooms:
                    for room in non_reused_rooms:
                        self.add_violation(violations, "check_room_reuse", 2, "Ca thi 2 không sử dụng lại phòng của ca 1", exam_date=date, extra_info=f"Mã phòng {room} không được sử dụng lại")
                    reused_message_printed = True

        if not violations:
            self.add_violation(violations, "check_room_reuse", 0, "Tất cả các mã phòng đều được sử dụng lại")

        return pd.DataFrame(violations)

    def check_exam_datetime(self, df, df_date):
        valid_times = df_date['Giờ thi'].tolist()
        valid_dates = pd.to_datetime(df_date['Ngày thi'], dayfirst=True).dt.date.tolist()
        violations = []

        for index, row in df.iterrows():
            exam_date = pd.to_datetime(row['Ngày thi'], dayfirst=True).date()
            exam_time = row['Giờ thi']

            if exam_date not in valid_dates:
                self.add_violation(violations, "check_exam_datetime", 2, "Ngày thi không hợp lệ", subject_id=row['Mã học phần mở rộng'], exam_date=row['Ngày thi'], exam_time=row['Giờ thi'], extra_info=f"Ngày thi {exam_date} không hợp lệ")
            if exam_time not in valid_times:
                self.add_violation(violations, "check_exam_datetime", 2, "Giờ thi không hợp lệ", subject_id=row['Mã học phần mở rộng'], exam_date=row['Ngày thi'], exam_time=row['Giờ thi'], extra_info=f"Ca thi {exam_time} không hợp lệ")

        if not violations:
            self.add_violation(violations, "check_exam_datetime", 0, "Ngày và giờ thi bình thường")

        return pd.DataFrame(violations)


    def calculate_required_rooms(self,df_cbdl, MAX_STUDENTS_PER_SHIFT, STUDENTS_PER_ROOM,THRESHOLD):
        required_rooms = {}

        for ma_hoc_phan, group in df_cbdl.groupby('Mã học phần mở rộng'):
            total_students = len(group)

            if total_students <= THRESHOLD:
                required_rooms[ma_hoc_phan] = 1
            else:
                rooms_needed = (total_students + STUDENTS_PER_ROOM - 1) // STUDENTS_PER_ROOM
                if total_students > MAX_STUDENTS_PER_SHIFT and rooms_needed % 2 != 0:
                    rooms_needed += 1

                base_students_per_room = total_students // rooms_needed
                students_distribution = [base_students_per_room] * rooms_needed

                for i in range(total_students % rooms_needed):
                    students_distribution[i] += 1

                required_rooms[ma_hoc_phan] = rooms_needed

        return required_rooms

    def check_room_assignment(self, df_cbdl, df):
        required_rooms_count = self.calculate_required_rooms(df_cbdl, self.MAX_STUDENTS_PER_SHIFT, self.STUDENTS_PER_ROOM, self.THRESHOLD)
        violations = []

        # Loại bỏ các bản ghi trùng lặp dựa trên 'Ca thi', 'Mã học phần mở rộng' và 'Mã phòng'
        df_unique_rooms = df.drop_duplicates(subset=['Ca thi', 'Mã học phần mở rộng', 'Mã phòng'])

        # Nhóm các sinh viên theo 'Mã học phần mở rộng' và tính tổng số lượng phòng duy nhất cho mỗi mã học phần mở rộng
        assigned_rooms = df_unique_rooms.groupby(['Mã học phần mở rộng', 'Ca thi'])['Mã phòng'].nunique().reset_index()
        assigned_rooms_total = assigned_rooms.groupby('Mã học phần mở rộng')['Mã phòng'].sum()

        for subject, required_rooms in required_rooms_count.items():
            if subject in assigned_rooms_total:
                assigned_rooms_count = assigned_rooms_total[subject]
                subject_rooms = df_unique_rooms[df_unique_rooms['Mã học phần mở rộng'] == subject]['Mã phòng'].unique()
            else:
                assigned_rooms_count = 0
                subject_rooms = []
            # Lấy tên của mã học phần mở rộng từ df_cbdl (giả sử có cột 'Tên học phần' trong dataframe này)
            subject_name = df_cbdl[df_cbdl['Mã học phần mở rộng'] == subject]['Tên học phần'].iloc[0]

            if assigned_rooms_count < required_rooms:
                extra_info = f"Có thể cần thêm {abs(required_rooms-assigned_rooms_count)} phòng"
                self.add_violation(violations, "check_room_assignment", 1, "Mã học phần mở rộng cần thêm phòng", subject_id=subject, subject_name=subject_name)
            elif assigned_rooms_count > required_rooms:
                excess_rooms = subject_rooms[-(assigned_rooms_count - required_rooms):]
                extra_info = f"Số phòng thừa: {assigned_rooms_count - required_rooms}"
                self.add_violation(violations, "check_room_assignment", 1, "Mã học phần mở rộng thừa phòng thi", subject_id=subject, subject_name=subject_name, extra_info=extra_info)

        if not violations:
            self.add_violation(violations, "check_room_assignment", 0, "Đã gán đủ phòng cho tất cả các Mã học phần mở rộng")

        return pd.DataFrame(violations)

    def check_schedule_per_day(self, df_input):
        shift_count = df_input.groupby(['MSV mở rộng', 'Ngày thi']).size().reset_index(name='số ca thi')
        violating_students = shift_count[shift_count['số ca thi'] > self.MAX_SHIFTS_PER_DAY_PER_STUDENTS]
        violations = []

        for index, row in violating_students.iterrows():
            self.add_violation(violations, "check_schedule_per_day", 2, "Sinh viên thi quá số ca thi tối đa trong 1 ngày", student_id=row['MSV mở rộng'], exam_date=row['Ngày thi'])

        if not violations:
            self.add_violation(violations, "check_schedule_per_day", 0, "Tất cả sinh viên đều thi tối đa số ca thi cho phép trong 1 ngày")

        return pd.DataFrame(violations)
    def save_results_to_excel(self, results, output_file, sheet_name='Kết quả'):
        # Tạo DataFrame từ kết quả
        df_results = pd.DataFrame(results)

        # Các cột cần lưu
        columns_to_save = ['Loại kiểm tra', 'Mã kết quả', 'Thông điệp', 'Mã học phần mở rộng',
                        'Tên học phần', 'Mã sinh viên mở rộng', 'Ngày thi', 'Giờ thi', 'Ghi chú']

        # Kiểm tra và điền các cột thiếu vào DataFrame
        for col in columns_to_save:
            if col not in df_results.columns:
                df_results[col] = None  # hoặc điền giá trị mặc định

        # Sắp xếp các kết quả theo Loại kiểm tra trước
        df_results.sort_values(by=['Loại kiểm tra'], inplace=True)

        # Lưu DataFrame xuống file Excel
        try:
            with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:
                df_results.to_excel(writer, sheet_name=sheet_name, index=False, header=True)

            print(f"Kết quả đã được lưu vào sheet '{sheet_name}' của file Excel: {output_file}")
        except Exception as e:
            print(f"Lỗi khi lưu file Excel: {e}")

    def Show_KtrPhanLich(self):
        self.parent.textBrowser_2.clear()
        if self.parent.df_input_tab2 is None or self.parent.df_cbdl_tab2 is None or self.parent.df_date_tab2 is None:
            self.parent.textBrowser_2.setText("Chưa có dữ liệu. Vui lòng chọn dữ liệu đầu vào.")
            return
        try:
            # Kiểm tra nếu các biến chưa phải là DataFrame thì mới đọc dữ liệu từ file
            if not isinstance(self.parent.df_input_tab2, pd.DataFrame):
                self.parent.df_input_tab2 = pd.read_excel(self.parent.label.text())
            if not isinstance(self.parent.df_cbdl_tab2, pd.DataFrame):
                self.parent.df_cbdl_tab2 = pd.read_excel(self.parent.label_2.text())
            if not isinstance(self.parent.df_date_tab2, pd.DataFrame):
                self.parent.df_date_tab2 = pd.read_excel(self.parent.label_3.text())

            self.parent.textBrowser_2.append("Đang kiểm tra phân lịch thi...")
            printed_messages = []
            
            # Khởi tạo danh sách để lưu trữ kết quả kiểm tra
            results = []
            results.append(self.check_student_per_shift(self.parent.df_input_tab2))
            results.append(self.check_subject_student_list(self.parent.df_input_tab2, self.parent.df_cbdl_tab2))
            results.append(self.check_student_in_room(self.parent.df_input_tab2))
            results.append(self.check_alter_subjects(self.parent.df_input_tab2))
            results.append(self.check_count_room_shift(self.parent.df_input_tab2))
            results.append(self.check_room_reuse(self.parent.df_input_tab2))
            results.append(self.check_exam_datetime(self.parent.df_input_tab2, self.parent.df_date_tab2))
            results.append(self.check_room_assignment(self.parent.df_cbdl_tab2, self.parent.df_input_tab2))
            results.append(self.check_schedule_per_day(self.parent.df_input_tab2))

            # Kết hợp các kết quả thành một DataFrame duy nhất
            combined_results = pd.concat(results, ignore_index=True)
            for index, row in combined_results.iterrows():
                message = f"Thông điệp: {row['Thông điệp']}, Mã kết quả: {row['Mã kết quả']}"

                # Kiểm tra xem thông điệp đã được in ra trước đó chưa
                if message not in printed_messages:
                    self.parent.textBrowser_2.append(message)
                    printed_messages.append(message)
            
            # Lưu kết quả vào thuộc tính 
            self.parent.combined_results = combined_results
            self.parent.XuatfileKtr.setEnabled(True)
        
        except Exception as e:
            QMessageBox.warning(self.parent, "Lỗi", f"Lỗi xử lý dữ liệu: {str(e)}")


    

